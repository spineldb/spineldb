// src/core/commands/generic/command_cmd.rs

use crate::core::commands::command_spec::CommandSpec;
use crate::core::commands::command_trait::{
    CommandFlags, ExecutableCommand, ParseCommand, WriteOutcome,
};
use crate::core::protocol::RespFrame;
use crate::core::storage::db::ExecutionContext;
use crate::core::{RespValue, SpinelDBError};
use async_trait::async_trait;
use bytes::Bytes;
use once_cell::sync::Lazy;

/// A command for introspecting other commands.
/// Corresponds to the `COMMAND` SpinelDB command.
#[derive(Debug, Clone, Default)]
pub struct CommandInfo;

impl ParseCommand for CommandInfo {
    fn parse(args: &[RespFrame]) -> Result<Self, SpinelDBError> {
        if !args.is_empty() {
            // SpinelDB' COMMAND can take subcommands, but this implementation does not yet.
            // For now, we only support the parameter-less variant.
            return Err(SpinelDBError::WrongArgumentCount("COMMAND".to_string()));
        }
        Ok(CommandInfo)
    }
}

impl CommandSpec for CommandInfo {
    fn name(&self) -> &'static str {
        "command"
    }
    fn arity(&self) -> i64 {
        // Arity is -1 because it can have subcommands, even if not implemented here.
        -1
    }
    fn flags(&self) -> CommandFlags {
        CommandFlags::ADMIN | CommandFlags::NO_PROPAGATE | CommandFlags::READONLY
    }
    fn first_key(&self) -> i64 {
        0
    }
    fn last_key(&self) -> i64 {
        0
    }
    fn step(&self) -> i64 {
        0
    }
    fn get_keys(&self) -> Vec<Bytes> {
        vec![]
    }
    fn to_resp_args(&self) -> Vec<Bytes> {
        vec![]
    }
}

/// Converts `CommandFlags` into a `Vec<RespValue>` of simple strings.
fn flags_to_resp_values(flags: CommandFlags) -> Vec<RespValue> {
    let mut flag_values = Vec::new();
    if flags.contains(CommandFlags::WRITE) {
        flag_values.push(RespValue::SimpleString("write".to_string()));
    }
    if flags.contains(CommandFlags::READONLY) {
        flag_values.push(RespValue::SimpleString("readonly".to_string()));
    }
    if flags.contains(CommandFlags::DENY_OOM) {
        flag_values.push(RespValue::SimpleString("denyoom".to_string()));
    }
    if flags.contains(CommandFlags::ADMIN) {
        flag_values.push(RespValue::SimpleString("admin".to_string()));
    }
    if flags.contains(CommandFlags::PUBSUB) {
        flag_values.push(RespValue::SimpleString("pubsub".to_string()));
    }
    if flags.contains(CommandFlags::NO_PROPAGATE) {
        flag_values.push(RespValue::SimpleString("no_propagate".to_string()));
    }
    if flags.contains(CommandFlags::TRANSACTION) {
        flag_values.push(RespValue::SimpleString("transaction".to_string()));
    }
    if flags.contains(CommandFlags::MOVABLEKEYS) {
        flag_values.push(RespValue::SimpleString("movablekeys".to_string()));
    }
    flag_values
}

/// Builds the detailed RESP response for a single command from its `CommandSpec`.
fn build_command_details_from_spec(spec: &dyn CommandSpec) -> RespValue {
    RespValue::Array(vec![
        RespValue::BulkString(spec.name().to_ascii_uppercase().into()),
        RespValue::Integer(spec.arity()),
        RespValue::Array(flags_to_resp_values(spec.flags())),
        RespValue::Integer(spec.first_key()),
        RespValue::Integer(spec.last_key()),
        RespValue::Integer(spec.step()),
    ])
}

// Lazily build and sort the command specifications once at startup.
static SORTED_COMMAND_SPECS: Lazy<Vec<RespValue>> = Lazy::new(|| {
    // Import the function generated by the `define_commands!` macro.
    use crate::core::commands::get_all_command_specs;
    let specs = get_all_command_specs();
    let mut details: Vec<_> = specs
        .iter()
        .map(|spec| build_command_details_from_spec(spec.as_ref()))
        .collect();

    // Sort the command details alphabetically by name for consistent output.
    details.sort_by(|a, b| {
        if let RespValue::Array(arr_a) = a
            && let RespValue::Array(arr_b) = b
            && let RespValue::BulkString(name_a) = &arr_a[0]
            && let RespValue::BulkString(name_b) = &arr_b[0]
        {
            return name_a.cmp(name_b);
        }
        std::cmp::Ordering::Equal
    });
    details
});

#[async_trait]
impl ExecutableCommand for CommandInfo {
    async fn execute<'a>(
        &self,
        _ctx: &mut ExecutionContext<'a>,
    ) -> Result<(RespValue, WriteOutcome), SpinelDBError> {
        // Return the pre-built, sorted list of command specifications.
        Ok((
            RespValue::Array(SORTED_COMMAND_SPECS.clone()),
            WriteOutcome::DidNotWrite,
        ))
    }
}
