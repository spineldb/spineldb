// src/core/commands/command_def.rs

//! Defines the main `Command` enum and its core implementations using a macro.
//! This approach centralizes command definitions, reducing boilerplate and ensuring
//! consistency across the command processing infrastructure.

#[macro_export]
macro_rules! define_commands {
    (
        dispatchers: {
            $( ($dispatcher_variant:ident, $dispatcher_struct:ident, $dispatcher_module:ident) ),*
        },
        standard: {
            $( ($variant:ident, $struct_name:ident, $module:ident) ),*
        }
    ) => {
        /// The primary enum representing all supported commands in the database.
        ///
        /// This enum is automatically generated by the `define_commands!` macro. Each variant
        /// holds the corresponding parsed command struct, which contains all the necessary
        /// arguments and options for that command's execution.
        #[derive(Debug, Clone)]
        pub enum Command {
            $(
                $dispatcher_variant($crate::core::commands::$dispatcher_module::$dispatcher_struct),
            )*
            $(
                $variant($crate::core::commands::$module::$struct_name),
            )*
            // Transaction control commands are handled specially.
            Multi,
            Exec,
            Discard,
        }

        impl Command {
            /// Returns the name of the command in lowercase (e.g., "get", "json").
            pub fn name(&self) -> &'static str {
                match self {
                    $(
                        Command::$dispatcher_variant(cmd) => cmd.name(),
                    )*
                    $(
                        Command::$variant(cmd) => cmd.name(),
                    )*
                    Command::Multi => "multi",
                    Command::Exec => "exec",
                    Command::Discard => "discard",
                }
            }

            /// Returns the command's arguments for logging or replication, excluding the command name itself.
            pub fn get_resp_args(&self) -> Vec<Bytes> {
                match self {
                    $(
                        Command::$dispatcher_variant(cmd) => cmd.to_resp_args(),
                    )*
                    $(
                        Command::$variant(cmd) => cmd.to_resp_args(),
                    )*
                    Command::Multi | Command::Exec | Command::Discard => vec![],
                }
            }
        }

        /// Implements `TryFrom<RespFrame>` for `Command`, providing the core parsing logic.
        ///
        /// This is the central parsing dispatcher. It reads the command name from the RESP Array
        /// and delegates to the appropriate command-specific `::parse()` method. It also includes
        /// logic for namespaced commands (e.g., `JSON.GET`).
        impl TryFrom<$crate::core::protocol::RespFrame> for Command {
            type Error = $crate::core::SpinelDBError;

            fn try_from(frame: $crate::core::protocol::RespFrame) -> Result<Self, Self::Error> {
                let array = match frame {
                    $crate::core::protocol::RespFrame::Array(arr) => arr,
                    _ => return Err($crate::core::SpinelDBError::SyntaxError),
                };
                if array.is_empty() { return Err($crate::core::SpinelDBError::SyntaxError); }

                let command_name = match &array[0] {
                    $crate::core::protocol::RespFrame::BulkString(bs) => String::from_utf8_lossy(bs).to_ascii_lowercase(),
                    _ => return Err($crate::core::SpinelDBError::SyntaxError),
                };
                let args = &array[1..];

                // Handle namespaced commands like `JSON.SET` or `CACHE.GET`.
                if command_name.contains('.') {
                    let parts: Vec<&str> = command_name.splitn(2, '.').collect();
                    let base_cmd = parts[0];
                    let sub_cmd = parts[1];

                    $(
                        if base_cmd == stringify!($dispatcher_variant).to_lowercase() {
                            let mut new_args = vec![$crate::core::protocol::RespFrame::BulkString(sub_cmd.to_uppercase().into())];
                            new_args.extend_from_slice(args);
                            return Ok(Command::$dispatcher_variant($crate::core::commands::$dispatcher_module::$dispatcher_struct::parse(&new_args)?));
                        }
                    )*
                }

                // Handle standard, non-namespaced commands.
                $(
                    if command_name == stringify!($variant).to_lowercase() {
                        return Ok(Command::$variant($crate::core::commands::$module::$struct_name::parse(args)?));
                    }
                )*

                // Handle dispatcher commands that are not namespaced (e.g., `CLUSTER NODES`).
                $(
                     if command_name == stringify!($dispatcher_variant).to_lowercase() {
                        return Ok(Command::$dispatcher_variant($crate::core::commands::$dispatcher_module::$dispatcher_struct::parse(args)?));
                    }
                )*

                if command_name == "multi" { return Ok(Command::Multi); }
                if command_name == "exec" { return Ok(Command::Exec); }
                if command_name == "discard" { return Ok(Command::Discard); }

                Err($crate::core::SpinelDBError::UnknownCommand(command_name.to_string()))
            }
        }

        #[async_trait]
        impl CommandExt for Command {
            fn get_flags(&self) -> CommandFlags {
                match self {
                    $(
                        Command::$dispatcher_variant(cmd) => cmd.flags(),
                    )*
                    $(
                        Command::$variant(cmd) => cmd.flags(),
                    )*
                    Command::Multi | Command::Exec | Command::Discard => CommandFlags::TRANSACTION | CommandFlags::NO_PROPAGATE,
                }
            }

            fn get_keys(&self) -> Vec<Bytes> {
                match self {
                     $(
                        Command::$dispatcher_variant(cmd) => cmd.get_keys(),
                    )*
                    $(
                        Command::$variant(cmd) => cmd.get_keys(),
                    )*
                    _ => vec![],
                }
            }

            async fn execute<'a>(
                &self,
                ctx: &mut ExecutionContext<'a>,
            ) -> Result<(RespValue, WriteOutcome), SpinelDBError> {
                match self {
                     $(
                        Command::$dispatcher_variant(cmd) => cmd.execute(ctx).await,
                    )*
                    $(
                        Command::$variant(cmd) => cmd.execute(ctx).await,
                    )*
                    _ => Err(SpinelDBError::Internal(format!(
                        "Command {:?} cannot be executed directly via the CommandExt trait.",
                        self
                    ))),
                }
            }

            async fn execute_and_stream<'a>(
                &self,
                ctx: &mut ExecutionContext<'a>,
            ) -> Result<RouteResponse, SpinelDBError> {
                match self {
                     Command::Cache(cmd) => match &cmd.subcommand {
                        $crate::core::commands::cache::command::CacheSubcommand::Get(get_cmd) => get_cmd.execute_and_stream(ctx).await,
                        $crate::core::commands::cache::command::CacheSubcommand::Proxy(proxy_cmd) => proxy_cmd.execute_and_stream(ctx).await,
                        _ => {
                            let (val, _outcome) = self.execute(ctx).await?;
                            Ok(RouteResponse::Single(val))
                        }
                     },
                     // For all other commands, use the default buffered implementation.
                    _ => {
                        let (val, _outcome) = self.execute(ctx).await?;
                        Ok(RouteResponse::Single(val))
                    }
                }
            }
        }

        impl From<Command> for $crate::core::protocol::RespFrame {
            fn from(cmd: Command) -> Self {
                let (name, args) = match cmd {
                    $(
                         Command::$dispatcher_variant(c) => (c.name().to_string(), c.to_resp_args()),
                    )*
                    $(
                        Command::$variant(c) => (c.name().to_string(), c.to_resp_args()),
                    )*
                    Command::Multi => ("multi".to_string(), vec![]),
                    Command::Exec => ("exec".to_string(), vec![]),
                    Command::Discard => ("discard".to_string(), vec![]),
                };

                let mut frames = vec![$crate::core::protocol::RespFrame::BulkString(name.to_ascii_uppercase().into())];
                frames.extend(args.into_iter().map($crate::core::protocol::RespFrame::BulkString));
                $crate::core::protocol::RespFrame::Array(frames)
            }
        }

        /// Returns a vector of all command specifications for introspection (e.g., `COMMAND` command).
        pub fn get_all_command_specs() -> Vec<Box<dyn CommandSpec + Send + Sync>> {
            vec![
                $(
                    Box::new($crate::core::commands::$dispatcher_module::$dispatcher_struct::default()),
                )*
                $(
                    Box::new($crate::core::commands::$module::$struct_name::default()),
                )*
            ]
        }
    };
}
